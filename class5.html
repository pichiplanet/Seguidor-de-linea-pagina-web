<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Clase 5: Algoritmo básico de seguimiento</title>
    <link rel="icon" type="image/png" href="assets/logo/white.png" />
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <nav>
      <a href="index.html" class="btn">
        <img src="assets/logo/white.png" width="50" />
      </a>
      <div class="class-nav" style="display: inline-block">
        <a href="class1.html" class="btn">Clase 1</a>
        <a href="class2.html" class="btn">Clase 2</a>
        <a href="class3.html" class="btn">Clase 3</a>
        <a href="class4.html" class="btn">Clase 4</a>
        <a href="class5.html" class="btn active">Clase 5</a>
        <a href="class6.html" class="btn">Clase 6</a>
        <a href="class7.html" class="btn">Clase 7</a>
      </div>
    </nav>

    <header>
      <img class="header-bg" src="assets/bg/escuela.jpg" />
      <h1>Clase 5: Algoritmo básico de seguimiento</h1>
      <div>Curso: Robot Seguidor de Línea</div>
    </header>

    <main>
      <section class="class-card">
        <h2 class="title">Objetivo de la clase</h2>
        <div class="content">
          <img class="class-img" src="assets/cards/brain.png" />
          <div>
            Implementar un algoritmo simple de control basado en los valores de los sensores para que el robot pueda seguir una línea negra sobre fondo blanco.
          </div>
        </div>
      </section>

      <section class="class-card">
        <h2 class="title">Video tutorial</h2>
        <div class="content">
          <iframe
            width="560"
            height="315"
            src="https://www.youtube.com/embed/-2xuO8JBepM?si=U5q6cJ6y37M42hEq"
            title="YouTube video player"
            frameborder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
            referrerpolicy="strict-origin-when-cross-origin"
            allowfullscreen
          ></iframe>
          <div>placeholder</div>
        </div>
      </section>

      <section class="class-card">
        <h2 class="title">Algoritmo de decisión</h2>
        <div class="content">
          <div style="width: 100%">
            <p>
              Usaremos los valores de los sensores para tomar decisiones sobre hacia qué dirección girar. Por ejemplo:
            </p>
            <ul>
              <li><strong>00010:</strong> centrado en la línea → avanzar recto</li>
              <li><strong>00110:</strong> ligeramente a la izquierda → girar a la izquierda</li>
              <li><strong>01100:</strong> más a la izquierda → girar más</li>
              <li><strong>10000:</strong> completamente a la izquierda → giro fuerte</li>
              <li><strong>00000:</strong> línea perdida → detener o buscar</li>
            </ul>
            <p>Esto se implementa en el loop utilizando condicionales.</p>
          </div>
        </div>
      </section>

      <section class="class-card">
        <h2 class="title">Código ejemplo</h2>
        <div class="content">
          <div style="width: 100%">

            <p>
              Primero leemos el estado de los sensores conectados a los pines digitales. Recordemos que el sensor devolverá <code>0</code> si ve negro (línea) y <code>1</code> si ve blanco (fondo).
            </p>
            <pre class="codeblock"><code>
// Lectura de sensores infrarrojos
bool s1 = digitalRead(PIN_SENSOR_1);  // Sensor más a la izquierda
bool s2 = digitalRead(PIN_SENSOR_2);
bool s3 = digitalRead(PIN_SENSOR_3);  // Sensor central
bool s4 = digitalRead(PIN_SENSOR_4);
bool s5 = digitalRead(PIN_SENSOR_5);  // Sensor más a la derecha
            </code></pre>

            <p>
              Luego usamos una estructura condicional para decidir qué acción tomar dependiendo de qué sensor detecta la línea negra. La prioridad está dada por qué sensor esté más cerca del centro:
            </p>
            <ul>
              <li><code>s3</code>: línea centrada → avanzar</li>
              <li><code>s2</code>: línea un poco a la izquierda → giro leve a la izquierda</li>
              <li><code>s1</code>: línea muy a la izquierda → giro fuerte a la izquierda</li>
              <li><code>s4</code>: línea un poco a la derecha → giro leve a la derecha</li>
              <li><code>s5</code>: línea muy a la derecha → giro fuerte a la derecha</li>
              <li>Ningún sensor detecta línea → detener</li>
            </ul>

            <pre class="codeblock"><code>
// Algoritmo de seguimiento de línea
if (s3 == 0) {
  avanzar();  // Sensor central detecta línea
} else if (s2 == 0) {
  girarIzquierdaLeve();
} else if (s1 == 0) {
  girarIzquierdaFuerte();
} else if (s4 == 0) {
  girarDerechaLeve();
} else if (s5 == 0) {
  girarDerechaFuerte();
} else {
  detener();  // Ningún sensor detecta la línea
}
            </code></pre>

            <p>
              A continuación definimos las funciones utilizadas para el movimiento del robot. Cada función envía señales a los pines del puente H y al PWM para controlar la dirección y velocidad de los motores.
            </p>

            <pre class="codeblock"><code>
// Funciones de movimiento

void avanzar() {
  digitalWrite(PIN_MOTOR_1A, HIGH);
  digitalWrite(PIN_MOTOR_1B, LOW);
  digitalWrite(PIN_MOTOR_2A, HIGH);
  digitalWrite(PIN_MOTOR_2B, LOW);
  analogWrite(PIN_PWM_MOTOR_1, 200);
  analogWrite(PIN_PWM_MOTOR_2, 200);
}

void girarIzquierdaLeve() {
  analogWrite(PIN_PWM_MOTOR_1, 150);
  analogWrite(PIN_PWM_MOTOR_2, 200);
}

void girarIzquierdaFuerte() {
  analogWrite(PIN_PWM_MOTOR_1, 100);
  analogWrite(PIN_PWM_MOTOR_2, 200);
}

void girarDerechaLeve() {
  analogWrite(PIN_PWM_MOTOR_1, 200);
  analogWrite(PIN_PWM_MOTOR_2, 150);
}

void girarDerechaFuerte() {
  analogWrite(PIN_PWM_MOTOR_1, 200);
  analogWrite(PIN_PWM_MOTOR_2, 100);
}

void detener() {
  analogWrite(PIN_PWM_MOTOR_1, 0);
  analogWrite(PIN_PWM_MOTOR_2, 0);
}
            </code></pre>

            <p>
              Este conjunto de instrucciones forma el primer algoritmo funcional de seguimiento de línea. Es una solución simple, pero efectiva para trayectos lineales o con curvas suaves.
            </p>

          </div>
        </div>
      </section>

      <section class="class-card">
        <h2 class="title">Próximos pasos</h2>
        <div class="content">
          <img class="class-img" src="assets/cards/placeholder.png" />
          <div>
            <p>
              En la siguiente clase analizaremos cómo ajustar la sensibilidad del robot y qué mejoras se pueden hacer al algoritmo para curvas o bifurcaciones.
            </p>
            <a class="link" href="class6.html">Ir a la clase 6 &rarr;</a>
          </div>
        </div>
      </section>
    </main>

    <footer>
      <a href="index.html" class="btn">Volver al inicio</a>
      <a href="mailto:juanbustos@eetp460.com" class="btn">Contacto</a>
      <a
        href="https://github.com/pichiplanet/Seguidor-de-linea-pagina-web/issues/new?labels=bug"
        class="btn"
        target="_blank"
        rel="noopener"
      >Reportar Bug</a>
    </footer>
  </body>
</html>
